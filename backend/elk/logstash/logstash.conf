input {
  http {
    port => 5044
    codec => json
  }

  file {
	path => [
      "/shared_logs/game_service.log",
      "/shared_logs/user_management.log",
      "/shared_logs/api_gateway.log",
      "/shared_logs/frontend.log"
    ]
    start_position => "beginning"
    codec => json
    tags => ["file"]
  }
}

filter {
  if "_jsonparsefailure" in [tags] {
    json {
      source => "message"
      remove_field => ["message"]
    }
  }

  if "favicon.ico" in [message] {
    drop { }
  }

  date {
    match => ["timestamp", "ISO8601"]
    target => "@timestamp"
  }

  if ![level] {
    mutate { add_field => { "level" => "info" } }
  }

  mutate {
    lowercase => ["level"]
  }
  
  # Arreglar URL
  if [url] {
    ruby {
      code => '
        event.set("[http][url_info]", event.get("url")) if event.get("url").is_a?(Hash)
        event.remove("url")
      '
    }
  }

  # Eliminar posibles  "_" de appName
  mutate {
    gsub => ["appName", "_", ""]
  }

  # ValidaciÃ³n segura del campo "log.source"
  if [source] {
    mutate {
      add_field => { "[event][dataset]" => "%{[source]}" }
    }
  } else {
    mutate {
      add_field => { "[event][dataset]" => "unknown_source" }
    }
  }

  # Gestionar payload
  if [payload] {
    json {
      source       => "payload"
      target       => "payload_obj"
    }
  }
  
  mutate {
    remove_field => ["payload"]
  }

  # Filtro para  vincular datos de "incoming request" con "request completed"
  if [msg] == "incoming request" {
    aggregate {
      task_id => "%{reqId}"
      code => "
        map['req_url'] = event.get('req')['url']
        map['req_method'] = event.get('req')['method']
      "
      map_action => "create"
      timeout => 30
    }
    mutate {
      add_field => { "event_type" => "request_start" }
    }
  }

  if [msg] == "request completed" {
    aggregate {
      task_id => "%{reqId}"
      code => "
        event.set('req_url', map['req_url'])
        event.set('req_method', map['req_method'])
      "
      map_action => "update"
    }
    mutate {
      add_field => {
        "event_type" => "request_end"
        "duration_ms" => "%{[responseTime]}"
        "status_code" => "%{[res][statusCode]}"
      }
    }
    mutate {
      convert => {
        "duration_ms" => "float"
        "status_code" => "integer"
      }
    }
  }
}

output {
  elasticsearch {
    hosts => ["${ELASTIC_URL}"]
    user => "${ELASTIC_US}"
    password => "${ELASTIC_PASSWORD}"
    ssl_enabled => true
    ssl_verification_mode => "full"
    ssl_certificate_authorities => ["/usr/share/logstash/config/certs/ca/ca.crt"]
    ilm_enabled => true
    ilm_policy => "logs_policy"
    ilm_rollover_alias => "%{[appName]}%{[via]}"
    ilm_pattern => "000001"
    manage_template => false
  }

  stdout {
    codec => rubydebug
  }
}
